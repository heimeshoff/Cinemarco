module GenericImport

open System
open Newtonsoft.Json.Linq
open Shared.Domain

// =====================================
// Generic Import Service
// =====================================
// Handles importing data from JSON files (generated by AI from various sources)
// into the Cinemarco library

// =====================================
// Import State
// =====================================

type private ImportState = {
    InProgress: bool
    CurrentItem: string option
    CurrentIndex: int
    TotalItems: int
    CompletedSuccessfully: int
    Skipped: int
    Errors: string list
    CancellationRequested: bool
    // Store items being processed for match confirmation
    ProcessingItems: GenericImportItemWithMatch list
}

let private importState = ref {
    InProgress = false
    CurrentItem = None
    CurrentIndex = 0
    TotalItems = 0
    CompletedSuccessfully = 0
    Skipped = 0
    Errors = []
    CancellationRequested = false
    ProcessingItems = []
}

/// Get the current import progress
let getProgress () : GenericImportProgress =
    let state = !importState
    {
        InProgress = state.InProgress
        CurrentItem = state.CurrentItem
        CurrentIndex = state.CurrentIndex
        TotalItems = state.TotalItems
        CompletedSuccessfully = state.CompletedSuccessfully
        Skipped = state.Skipped
        Errors = state.Errors
    }

/// Request cancellation of the import
let requestCancellation () =
    importState := { !importState with CancellationRequested = true }

/// Reset import state
let private resetState () =
    importState := {
        InProgress = false
        CurrentItem = None
        CurrentIndex = 0
        TotalItems = 0
        CompletedSuccessfully = 0
        Skipped = 0
        Errors = []
        CancellationRequested = false
        ProcessingItems = []
    }

let private updateProgress item index =
    importState := { !importState with CurrentItem = Some item; CurrentIndex = index }

let private addError error =
    let state = !importState
    importState := { state with Errors = state.Errors @ [error] }

let private incrementCompleted () =
    let state = !importState
    importState := { state with CompletedSuccessfully = state.CompletedSuccessfully + 1 }

let private incrementSkipped () =
    let state = !importState
    importState := { state with Skipped = state.Skipped + 1 }

let private isCancelled () = (!importState).CancellationRequested

// =====================================
// JSON Parsing
// =====================================

let private parseDateTime (s: string) : DateTime option =
    match DateTime.TryParse(s) with
    | true, d -> Some d
    | false, _ -> None

let private parseRating (token: JToken) : PersonalRating option =
    if isNull token || token.Type = JTokenType.Null then None
    else
        let ratingStr = token.Value<string>()
        match ratingStr.ToLowerInvariant() with
        | "outstanding" -> Some Outstanding
        | "entertaining" -> Some Entertaining
        | "decent" -> Some Decent
        | "meh" -> Some Meh
        | "waste" -> Some Waste
        | _ -> None

let private parseEpisode (obj: JToken) : GenericImportEpisode option =
    try
        Some {
            SeasonNumber = obj.["season"].Value<int>()
            EpisodeNumber = obj.["episode"].Value<int>()
            WatchedDate =
                match obj.["watched"] with
                | null -> None
                | t -> parseDateTime (t.Value<string>())
        }
    with _ -> None

let private parseSeason (obj: JToken) : GenericImportSeason option =
    try
        Some {
            SeasonNumber = obj.["season"].Value<int>()
            WatchedDate =
                match obj.["watched"] with
                | null -> None
                | t -> parseDateTime (t.Value<string>())
        }
    with _ -> None

let private parseItem (obj: JToken) : GenericImportItem option =
    try
        let title = obj.["title"].Value<string>()
        let mediaType =
            match obj.["type"].Value<string>().ToLowerInvariant() with
            | "movie" -> ImportMovie
            | "series" | "tv" | "show" -> ImportSeries
            | _ -> ImportMovie  // Default to movie

        let year =
            match obj.["year"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t -> Some (t.Value<int>())

        let tmdbId =
            match obj.["tmdb_id"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t -> Some (t.Value<int>())

        let watchDates =
            match obj.["watched"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t.ToObject<string list>()
                |> List.choose parseDateTime
            | t ->
                parseDateTime (t.Value<string>())
                |> Option.map List.singleton
                |> Option.defaultValue []

        let seasons =
            match obj.["seasons"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseSeason |> Seq.toList
            | _ -> []

        let episodes =
            match obj.["episodes"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseEpisode |> Seq.toList
            | _ -> []

        let friendNames =
            match obj.["watched_with"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t.ToObject<string list>()
            | t -> [t.Value<string>()]

        let notes =
            match obj.["notes"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        let source =
            match obj.["source"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        Some {
            Title = title
            Year = year
            MediaType = mediaType
            TmdbId = tmdbId
            WatchDates = watchDates
            Seasons = seasons
            Episodes = episodes
            Rating = parseRating obj.["rating"]
            Notes = notes
            FriendNames = friendNames
            Source = source
        }
    with ex ->
        printfn "[GenericImport] Failed to parse item: %s" ex.Message
        None

/// Parse a JSON string into import items
let parseJson (jsonString: string) : Result<GenericImportItem list, string> =
    try
        let json = JObject.Parse(jsonString)
        let items =
            match json.["items"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseItem |> Seq.toList
            | _ -> []

        if items.IsEmpty then
            Error "No valid items found in JSON. Expected { \"items\": [...] } format."
        else
            Ok items
    with ex ->
        Error $"Failed to parse JSON: {ex.Message}"

// =====================================
// TMDB Matching
// =====================================

let private matchWithTmdb (item: GenericImportItem) : Async<GenericImportMatchStatus> = async {
    match item.TmdbId with
    | Some tmdbId ->
        // Direct lookup by ID
        match item.MediaType with
        | ImportMovie ->
            let! result = TmdbClient.getMovieDetails (TmdbMovieId tmdbId)
            match result with
            | Ok details ->
                return ExactMatch {
                    TmdbId = tmdbId
                    MediaType = Movie
                    Title = details.Title
                    ReleaseDate = details.ReleaseDate
                    PosterPath = details.PosterPath
                    Overview = details.Overview
                    VoteAverage = details.VoteAverage
                }
            | Error _ -> return NoMatchFound
        | ImportSeries ->
            let! result = TmdbClient.getSeriesDetails (TmdbSeriesId tmdbId)
            match result with
            | Ok details ->
                return ExactMatch {
                    TmdbId = tmdbId
                    MediaType = Series
                    Title = details.Name
                    ReleaseDate = details.FirstAirDate
                    PosterPath = details.PosterPath
                    Overview = details.Overview
                    VoteAverage = details.VoteAverage
                }
            | Error _ -> return NoMatchFound
    | None ->
        // Search by title + year
        let query =
            match item.Year with
            | Some y -> $"{item.Title} {y}"
            | None -> item.Title

        let! results = TmdbClient.searchAll query

        // Filter by media type
        let filtered =
            results
            |> List.filter (fun r ->
                match item.MediaType with
                | ImportMovie -> r.MediaType = Movie
                | ImportSeries -> r.MediaType = Series)

        match filtered with
        | [] -> return NoMatchFound
        | [single] -> return ExactMatch single
        | multiple ->
            // Check if any is an exact title + year match
            let exactMatch =
                multiple
                |> List.tryFind (fun r ->
                    r.Title.Equals(item.Title, StringComparison.OrdinalIgnoreCase) &&
                    (match item.Year, r.ReleaseDate with
                     | Some y, Some d -> d.Year = y
                     | _, _ -> false))
            match exactMatch with
            | Some exact -> return ExactMatch exact
            | None -> return MultipleMatches multiple
}

// =====================================
// Friend Resolution
// =====================================

let private resolveFriends (friendNames: string list) : Async<GenericImportFriendResolution list> = async {
    let! allFriends = Persistence.getAllFriends()
    return friendNames
        |> List.map (fun name ->
            let existing =
                allFriends
                |> List.tryFind (fun f ->
                    f.Name.Equals(name, StringComparison.OrdinalIgnoreCase) ||
                    (f.Nickname |> Option.map (fun n -> n.Equals(name, StringComparison.OrdinalIgnoreCase)) |> Option.defaultValue false))
            match existing with
            | Some friend -> ExistingFriend friend.Id
            | None -> NewFriend name)
}

// =====================================
// Preview Generation
// =====================================

/// Generate a preview of what will be imported (with TMDB matching)
let generatePreview (items: GenericImportItem list) : Async<Result<GenericImportPreview, string>> = async {
    try
        let! itemsWithMatches =
            items
            |> List.mapi (fun idx item -> async {
                printfn "[GenericImport] Matching item %d/%d: %s" (idx + 1) items.Length item.Title
                let! matchStatus = matchWithTmdb item
                let! existsInLibrary =
                    match matchStatus with
                    | ExactMatch r | MatchConfirmed r ->
                        match item.MediaType with
                        | ImportMovie ->
                            async {
                                let! result = Persistence.isMovieInLibrary (TmdbMovieId r.TmdbId)
                                return result.IsSome
                            }
                        | ImportSeries ->
                            async {
                                let! result = Persistence.isSeriesInLibrary (TmdbSeriesId r.TmdbId)
                                return result.IsSome
                            }
                    | _ -> async { return false }
                let! resolvedFriends = resolveFriends item.FriendNames
                return {
                    ImportItem = item
                    MatchStatus = matchStatus
                    ExistsInLibrary = existsInLibrary
                    ResolvedFriends = resolvedFriends
                }
            })
            |> Async.Sequential

        let itemsList = itemsWithMatches |> Array.toList

        // Store in state for later confirmation
        importState := { !importState with ProcessingItems = itemsList }

        // Collect new friends to create
        let newFriendsToCreate =
            itemsList
            |> List.collect (fun i ->
                i.ResolvedFriends
                |> List.choose (fun r ->
                    match r with
                    | NewFriend name -> Some name
                    | _ -> None))
            |> List.distinct

        return Ok {
            Items = itemsList
            TotalItems = itemsList.Length
            ExactMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with ExactMatch _ | MatchConfirmed _ -> true | _ -> false) |> List.length
            AmbiguousMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with MultipleMatches _ -> true | _ -> false) |> List.length
            NoMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with NoMatchFound -> true | _ -> false) |> List.length
            AlreadyInLibrary = itemsList |> List.filter (fun i -> i.ExistsInLibrary) |> List.length
            NewFriendsToCreate = newFriendsToCreate
        }
    with ex ->
        return Error $"Failed to generate preview: {ex.Message}"
}

/// Confirm a TMDB match for an ambiguous item
let confirmMatch (index: int) (selectedMatch: TmdbSearchResult) : Async<Result<GenericImportItemWithMatch, string>> = async {
    let state = !importState
    if index < 0 || index >= state.ProcessingItems.Length then
        return Error $"Invalid item index: {index}"
    else
        let item = state.ProcessingItems.[index]
        let! existsInLibrary =
            match item.ImportItem.MediaType with
            | ImportMovie ->
                async {
                    let! result = Persistence.isMovieInLibrary (TmdbMovieId selectedMatch.TmdbId)
                    return result.IsSome
                }
            | ImportSeries ->
                async {
                    let! result = Persistence.isSeriesInLibrary (TmdbSeriesId selectedMatch.TmdbId)
                    return result.IsSome
                }

        let updatedItem = {
            item with
                MatchStatus = MatchConfirmed selectedMatch
                ExistsInLibrary = existsInLibrary
        }

        // Update the item in state
        let updatedItems =
            state.ProcessingItems
            |> List.mapi (fun i x -> if i = index then updatedItem else x)
        importState := { state with ProcessingItems = updatedItems }

        return Ok updatedItem
}

// =====================================
// Import Execution
// =====================================

/// Import a single movie
let private importMovie (item: GenericImportItemWithMatch) (tmdbResult: TmdbSearchResult) : Async<Result<unit, string>> = async {
    let tmdbId = TmdbMovieId tmdbResult.TmdbId

    // Check if already in library
    let! existing = Persistence.isMovieInLibrary tmdbId
    match existing with
    | Some entryId ->
        // Movie already exists - add watch sessions for new dates
        for watchDate in item.ImportItem.WatchDates do
            let! sessionExists = Persistence.movieWatchSessionExistsForDate entryId watchDate
            if not sessionExists then
                // Get resolved friend IDs (only existing friends, new ones will be created)
                let friendIds =
                    item.ResolvedFriends
                    |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

                let request: CreateMovieWatchSessionRequest = {
                    EntryId = entryId
                    WatchedDate = watchDate
                    Friends = friendIds
                    Name = Some "Generic Import"
                }
                let! _ = Persistence.insertMovieWatchSession request
                do! Persistence.markMovieWatched entryId (Some watchDate)

        // Update rating if we have one and entry doesn't
        match item.ImportItem.Rating with
        | Some rating ->
            let! entry = Persistence.getLibraryEntryById entryId
            match entry with
            | Some e when e.PersonalRating.IsNone ->
                do! Persistence.updatePersonalRating entryId (Some rating)
            | _ -> ()
        | None -> ()

        // Update notes if we have some and entry doesn't
        match item.ImportItem.Notes with
        | Some notes ->
            let! entry = Persistence.getLibraryEntryById entryId
            match entry with
            | Some e when e.Notes.IsNone ->
                do! Persistence.updateNotes entryId (Some notes)
            | _ -> ()
        | None -> ()

        return Ok ()
    | None ->
        // New movie - add to library
        let! detailsResult = TmdbClient.getMovieDetails tmdbId
        match detailsResult with
        | Error err -> return Error $"Failed to fetch movie details for {item.ImportItem.Title}: {err}"
        | Ok details ->
            // Cache images
            do! ImageCache.downloadPoster details.PosterPath
            do! ImageCache.downloadBackdrop details.BackdropPath

            // Get resolved friend IDs
            let friendIds =
                item.ResolvedFriends
                |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

            let request: AddMovieRequest = {
                TmdbId = tmdbId
                WhyAdded = Some {
                    RecommendedBy = None
                    RecommendedByName = None
                    Source = item.ImportItem.Source |> Option.orElse (Some "Generic Import")
                    Context = None
                    DateRecommended = None
                }
                InitialFriends = friendIds
            }

            let! entryResult = Persistence.insertLibraryEntryForMovie details request
            match entryResult with
            | Error err -> return Error err
            | Ok entry ->
                // Create watch sessions
                for watchDate in item.ImportItem.WatchDates do
                    let sessionRequest: CreateMovieWatchSessionRequest = {
                        EntryId = entry.Id
                        WatchedDate = watchDate
                        Friends = friendIds
                        Name = Some "Generic Import"
                    }
                    let! _ = Persistence.insertMovieWatchSession sessionRequest
                    do! Persistence.markMovieWatched entry.Id (Some watchDate)

                // Set rating
                match item.ImportItem.Rating with
                | Some rating -> do! Persistence.updatePersonalRating entry.Id (Some rating)
                | None -> ()

                // Set notes
                match item.ImportItem.Notes with
                | Some notes -> do! Persistence.updateNotes entry.Id (Some notes)
                | None -> ()

                return Ok ()
}

/// Import a single series
let private importSeries (item: GenericImportItemWithMatch) (tmdbResult: TmdbSearchResult) : Async<Result<unit, string>> = async {
    let tmdbId = TmdbSeriesId tmdbResult.TmdbId

    // Check if already in library
    let! existing = Persistence.isSeriesInLibrary tmdbId
    match existing with
    | Some entryId ->
        // Series already exists - import episode/season data
        let! entry = Persistence.getLibraryEntryById entryId
        match entry with
        | None -> return Error "Entry not found after check"
        | Some e ->
            let seriesId =
                match e.Media with
                | LibrarySeries s -> s.Id
                | _ -> failwith "Expected series"

            let! defaultSession = Persistence.getDefaultSession entryId
            match defaultSession with
            | None -> return Error "No default session found"
            | Some session ->
                // Import season-level data
                for season in item.ImportItem.Seasons do
                    // Fetch season details to get episode count
                    let! seasonDetails = TmdbClient.getSeasonDetails tmdbId season.SeasonNumber
                    match seasonDetails with
                    | Ok details ->
                        for ep in details.Episodes do
                            do! Persistence.insertEpisodeProgressWithDate
                                    session.Id
                                    entryId
                                    seriesId
                                    season.SeasonNumber
                                    ep.EpisodeNumber
                                    season.WatchedDate
                    | Error _ -> ()

                // Import episode-level data
                for ep in item.ImportItem.Episodes do
                    do! Persistence.insertEpisodeProgressWithDate
                            session.Id
                            entryId
                            seriesId
                            ep.SeasonNumber
                            ep.EpisodeNumber
                            ep.WatchedDate

                // Update watch status
                do! Persistence.updateSeriesWatchStatusFromProgress entryId

                // Update rating if we have one and entry doesn't
                match item.ImportItem.Rating with
                | Some rating ->
                    match e.PersonalRating with
                    | None -> do! Persistence.updatePersonalRating entryId (Some rating)
                    | _ -> ()
                | None -> ()

                return Ok ()
    | None ->
        // New series - add to library
        let! detailsResult = TmdbClient.getSeriesDetails tmdbId
        match detailsResult with
        | Error err -> return Error $"Failed to fetch series details for {item.ImportItem.Title}: {err}"
        | Ok details ->
            // Cache images
            do! ImageCache.downloadPoster details.PosterPath
            do! ImageCache.downloadBackdrop details.BackdropPath

            // Get resolved friend IDs
            let friendIds =
                item.ResolvedFriends
                |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

            let request: AddSeriesRequest = {
                TmdbId = tmdbId
                WhyAdded = Some {
                    RecommendedBy = None
                    RecommendedByName = None
                    Source = item.ImportItem.Source |> Option.orElse (Some "Generic Import")
                    Context = None
                    DateRecommended = None
                }
                InitialFriends = friendIds
            }

            let! entryResult = Persistence.insertLibraryEntryForSeries details request
            match entryResult with
            | Error err -> return Error err
            | Ok entry ->
                let seriesId =
                    match entry.Media with
                    | LibrarySeries s -> s.Id
                    | _ -> failwith "Expected series"

                let! defaultSession = Persistence.getDefaultSession entry.Id
                match defaultSession with
                | None -> return Error "No default session created"
                | Some session ->
                    // Import season-level data
                    for season in item.ImportItem.Seasons do
                        let! seasonDetails = TmdbClient.getSeasonDetails tmdbId season.SeasonNumber
                        match seasonDetails with
                        | Ok seasonDetail ->
                            // Cache season poster
                            do! ImageCache.downloadSeasonPoster seasonDetail.PosterPath
                            for ep in seasonDetail.Episodes do
                                do! Persistence.insertEpisodeProgressWithDate
                                        session.Id
                                        entry.Id
                                        seriesId
                                        season.SeasonNumber
                                        ep.EpisodeNumber
                                        season.WatchedDate
                        | Error _ -> ()

                    // Import episode-level data
                    for ep in item.ImportItem.Episodes do
                        do! Persistence.insertEpisodeProgressWithDate
                                session.Id
                                entry.Id
                                seriesId
                                ep.SeasonNumber
                                ep.EpisodeNumber
                                ep.WatchedDate

                    // Update watch status
                    do! Persistence.updateSeriesWatchStatusFromProgress entry.Id

                    // Set rating
                    match item.ImportItem.Rating with
                    | Some rating -> do! Persistence.updatePersonalRating entry.Id (Some rating)
                    | None -> ()

                    // Set notes
                    match item.ImportItem.Notes with
                    | Some notes -> do! Persistence.updateNotes entry.Id (Some notes)
                    | None -> ()

                    return Ok ()
}

/// Create new friends that don't exist yet
let private createNewFriends (items: GenericImportItemWithMatch list) : Async<Map<string, FriendId>> = async {
    let newFriendNames =
        items
        |> List.collect (fun i ->
            i.ResolvedFriends
            |> List.choose (fun r ->
                match r with
                | NewFriend name -> Some name
                | _ -> None))
        |> List.distinct

    let! newFriends =
        newFriendNames
        |> List.map (fun name -> async {
            try
                let request: CreateFriendRequest = { Name = name; Nickname = None }
                let! friend = Persistence.insertFriend request
                return Some (name, friend.Id)
            with _ ->
                return None
        })
        |> Async.Sequential

    return
        newFriends
        |> Array.choose id
        |> Array.toList
        |> Map.ofList
}

/// Start the import process
let startImport (items: GenericImportItemWithMatch list) : Async<Result<unit, string>> = async {
    // Filter to only items with confirmed matches
    let importableItems =
        items
        |> List.filter (fun i ->
            match i.MatchStatus with
            | ExactMatch _ | MatchConfirmed _ -> true
            | _ -> false)

    if importableItems.IsEmpty then
        return Error "No items with valid TMDB matches to import"
    else
        // Reset and start
        resetState ()
        importState := {
            !importState with
                InProgress = true
                TotalItems = importableItems.Length
                ProcessingItems = importableItems
        }

        try
            // Create new friends first
            let! newFriendMap = createNewFriends importableItems

            // Update items with new friend IDs
            let itemsWithNewFriends =
                importableItems
                |> List.map (fun item ->
                    let updatedFriends =
                        item.ResolvedFriends
                        |> List.map (fun r ->
                            match r with
                            | NewFriend name ->
                                match Map.tryFind name newFriendMap with
                                | Some id -> ExistingFriend id
                                | None -> r  // Keep as NewFriend if creation failed
                            | existing -> existing)
                    { item with ResolvedFriends = updatedFriends })

            // Import each item
            for idx in 0 .. itemsWithNewFriends.Length - 1 do
                if isCancelled () then
                    addError "Import cancelled by user"
                else
                    let item = itemsWithNewFriends.[idx]
                    let title = item.ImportItem.Title
                    updateProgress title idx

                    let tmdbResult =
                        match item.MatchStatus with
                        | ExactMatch r | MatchConfirmed r -> Some r
                        | _ -> None

                    match tmdbResult with
                    | None ->
                        incrementSkipped ()
                    | Some result ->
                        let! importResult =
                            match item.ImportItem.MediaType with
                            | ImportMovie -> importMovie item result
                            | ImportSeries -> importSeries item result

                        match importResult with
                        | Ok () -> incrementCompleted ()
                        | Error err ->
                            addError $"{title}: {err}"
                            incrementSkipped ()

            importState := { !importState with InProgress = false }
            return Ok ()
        with ex ->
            importState := { !importState with InProgress = false }
            return Error $"Import failed: {ex.Message}"
}
