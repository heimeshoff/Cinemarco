module GenericImport

open System
open Newtonsoft.Json.Linq
open Shared.Domain

// =====================================
// Generic Import Service
// =====================================
// Handles importing data from JSON files (generated by AI from various sources)
// into the Cinemarco library

// =====================================
// Import State
// =====================================

type private ImportState = {
    InProgress: bool
    CurrentItem: string option
    CurrentIndex: int
    TotalItems: int
    CompletedSuccessfully: int
    Skipped: int
    Errors: string list
    CancellationRequested: bool
    // Store items being processed for match confirmation
    ProcessingItems: GenericImportItemWithMatch list
    // Track imported items for summary display
    ImportedItems: ImportedItemInfo list
    // Track skipped items for summary display
    SkippedItems: ImportedItemInfo list
}

let private importState = ref {
    InProgress = false
    CurrentItem = None
    CurrentIndex = 0
    TotalItems = 0
    CompletedSuccessfully = 0
    Skipped = 0
    Errors = []
    CancellationRequested = false
    ProcessingItems = []
    ImportedItems = []
    SkippedItems = []
}

/// Get the current import progress
let getProgress () : GenericImportProgress =
    let state = !importState
    {
        InProgress = state.InProgress
        CurrentItem = state.CurrentItem
        CurrentIndex = state.CurrentIndex
        TotalItems = state.TotalItems
        CompletedSuccessfully = state.CompletedSuccessfully
        Skipped = state.Skipped
        Errors = state.Errors
        ImportedItems = state.ImportedItems
        SkippedItems = state.SkippedItems
    }

/// Request cancellation of the import
let requestCancellation () =
    importState := { !importState with CancellationRequested = true }

/// Reset import state
let private resetState () =
    importState := {
        InProgress = false
        CurrentItem = None
        CurrentIndex = 0
        TotalItems = 0
        CompletedSuccessfully = 0
        Skipped = 0
        Errors = []
        CancellationRequested = false
        ProcessingItems = []
        ImportedItems = []
        SkippedItems = []
    }

let private updateProgress item index =
    importState := { !importState with CurrentItem = Some item; CurrentIndex = index }

let private addError error =
    let state = !importState
    importState := { state with Errors = state.Errors @ [error] }

let private incrementCompleted () =
    let state = !importState
    importState := { state with CompletedSuccessfully = state.CompletedSuccessfully + 1 }

let private incrementSkipped () =
    let state = !importState
    importState := { state with Skipped = state.Skipped + 1 }

let private addImportedItem (info: ImportedItemInfo) =
    let state = !importState
    importState := { state with ImportedItems = state.ImportedItems @ [info] }

let private addSkippedItem (info: ImportedItemInfo) =
    let state = !importState
    importState := { state with SkippedItems = state.SkippedItems @ [info] }

let private isCancelled () = (!importState).CancellationRequested

// =====================================
// JSON Parsing
// =====================================

let private parseDateTime (s: string) : DateTime option =
    match DateTime.TryParse(s) with
    | true, d -> Some d
    | false, _ -> None

let private parseRating (token: JToken) : PersonalRating option =
    if isNull token || token.Type = JTokenType.Null then None
    else
        let ratingStr = token.Value<string>()
        match ratingStr.ToLowerInvariant() with
        | "outstanding" -> Some Outstanding
        | "entertaining" -> Some Entertaining
        | "decent" -> Some Decent
        | "meh" -> Some Meh
        | "waste" -> Some Waste
        | _ -> None

let private parseEpisode (obj: JToken) : GenericImportEpisode option =
    try
        Some {
            SeasonNumber = obj.["season"].Value<int>()
            EpisodeNumber = obj.["episode"].Value<int>()
            WatchedDate =
                match obj.["watched"] with
                | null -> None
                | t -> parseDateTime (t.Value<string>())
        }
    with _ -> None

let private parseSeason (obj: JToken) : GenericImportSeason option =
    try
        Some {
            SeasonNumber = obj.["season"].Value<int>()
            WatchedDate =
                match obj.["watched"] with
                | null -> None
                | t -> parseDateTime (t.Value<string>())
        }
    with _ -> None

let private parseItem (obj: JToken) : GenericImportItem option =
    try
        let title = obj.["title"].Value<string>()

        let id =
            match obj.["id"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        let mediaType =
            match obj.["type"].Value<string>().ToLowerInvariant() with
            | "movie" -> ImportMovie
            | "series" | "tv" | "show" -> ImportSeries
            | _ -> ImportMovie  // Default to movie

        let year =
            match obj.["year"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t -> Some (t.Value<int>())

        let tmdbId =
            match obj.["tmdb_id"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t -> Some (t.Value<int>())

        let imdbId =
            match obj.["imdb_id"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        let watchDates =
            match obj.["watched"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t.ToObject<string list>()
                |> List.choose parseDateTime
            | t ->
                parseDateTime (t.Value<string>())
                |> Option.map List.singleton
                |> Option.defaultValue []

        let seasons =
            match obj.["seasons"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseSeason |> Seq.toList
            | _ -> []

        let episodes =
            match obj.["episodes"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseEpisode |> Seq.toList
            | _ -> []

        let friendNames =
            match obj.["watched_with"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t.ToObject<string list>()
            | t -> [t.Value<string>()]

        let notes =
            match obj.["notes"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        let source =
            match obj.["source"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        Some {
            Id = id
            Title = title
            Year = year
            MediaType = mediaType
            TmdbId = tmdbId
            ImdbId = imdbId
            WatchDates = watchDates
            Seasons = seasons
            Episodes = episodes
            Rating = parseRating obj.["rating"]
            Notes = notes
            FriendNames = friendNames
            Source = source
        }
    with ex ->
        printfn "[GenericImport] Failed to parse item: %s" ex.Message
        None

/// Parse a collection item reference from JSON
let private parseCollectionItemRef (obj: JToken) : GenericImportCollectionItemRef option =
    try
        // Check for custom id reference first
        let customId =
            match obj.["id"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let id = t.Value<string>()
                if String.IsNullOrWhiteSpace id then None else Some id

        match customId with
        | Some id -> Some (ByCustomId id)
        | None ->
            // Check for IMDB ID reference
            let imdbId =
                match obj.["imdb_id"] with
                | null -> None
                | t when t.Type = JTokenType.Null -> None
                | t ->
                    let id = t.Value<string>()
                    if String.IsNullOrWhiteSpace id then None else Some id

            match imdbId with
            | Some id -> Some (ByImdbId id)
            | None ->
                // Check for TMDB ID reference (requires type)
                match obj.["tmdb_id"] with
                | null -> None
                | t when t.Type = JTokenType.Null -> None
                | t ->
                    let tmdbId = t.Value<int>()
                    let mediaType =
                        match obj.["type"] with
                        | null -> ImportMovie // Default to movie if not specified
                        | typeToken ->
                            match typeToken.Value<string>().ToLowerInvariant() with
                            | "movie" -> ImportMovie
                            | "series" | "tv" | "show" -> ImportSeries
                            | _ -> ImportMovie
                    Some (ByTmdbId (tmdbId, mediaType))
    with ex ->
        printfn "[GenericImport] Failed to parse collection item ref: %s" ex.Message
        None

/// Parse a collection from JSON
let private parseCollection (obj: JToken) : GenericImportCollection option =
    try
        let name =
            match obj.["name"] with
            | null -> None
            | t when t.Type = JTokenType.Null -> None
            | t ->
                let s = t.Value<string>()
                if String.IsNullOrWhiteSpace s then None else Some s

        match name with
        | None -> None // Name is required
        | Some collectionName ->
            let description =
                match obj.["description"] with
                | null -> None
                | t when t.Type = JTokenType.Null -> None
                | t ->
                    let s = t.Value<string>()
                    if String.IsNullOrWhiteSpace s then None else Some s

            let itemRefs =
                match obj.["items"] with
                | null -> []
                | t when t.Type = JTokenType.Array ->
                    t |> Seq.choose parseCollectionItemRef |> Seq.toList
                | _ -> []

            if itemRefs.IsEmpty then
                printfn "[GenericImport] Skipping collection '%s' - no valid item references" collectionName
                None
            else
                Some {
                    Name = collectionName
                    Description = description
                    ItemRefs = itemRefs
                }
    with ex ->
        printfn "[GenericImport] Failed to parse collection: %s" ex.Message
        None

/// Parse a JSON string into import items and collections
let parseJson (jsonString: string) : Result<GenericImportParseResult, string> =
    try
        let json = JObject.Parse(jsonString)
        let items =
            match json.["items"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseItem |> Seq.toList
            | _ -> []

        let collections =
            match json.["collections"] with
            | null -> []
            | t when t.Type = JTokenType.Array ->
                t |> Seq.choose parseCollection |> Seq.toList
            | _ -> []

        if items.IsEmpty then
            Error "No valid items found in JSON. Expected { \"items\": [...] } format."
        else
            Ok { Items = items; Collections = collections }
    with ex ->
        Error $"Failed to parse JSON: {ex.Message}"

// =====================================
// TMDB Matching
// =====================================

let private matchByTitleSearch (item: GenericImportItem) : Async<GenericImportMatchStatus> = async {
    let query =
        match item.Year with
        | Some y -> $"{item.Title} {y}"
        | None -> item.Title

    let! results = TmdbClient.searchAll query

    // Filter by media type
    let filtered =
        results
        |> List.filter (fun r ->
            match item.MediaType with
            | ImportMovie -> r.MediaType = Movie
            | ImportSeries -> r.MediaType = Series)

    match filtered with
    | [] -> return NoMatchFound
    | [single] -> return ExactMatch single
    | multiple ->
        // Check if any is an exact title + year match
        let exactMatch =
            multiple
            |> List.tryFind (fun r ->
                r.Title.Equals(item.Title, StringComparison.OrdinalIgnoreCase) &&
                (match item.Year, r.ReleaseDate with
                 | Some y, Some d -> d.Year = y
                 | _, _ -> false))
        match exactMatch with
        | Some exact -> return ExactMatch exact
        | None -> return MultipleMatches multiple
}

let private matchWithTmdb (item: GenericImportItem) : Async<GenericImportMatchStatus> = async {
    // Priority 1: Direct TMDB ID lookup
    match item.TmdbId with
    | Some tmdbId ->
        match item.MediaType with
        | ImportMovie ->
            let! result = TmdbClient.getMovieDetails (TmdbMovieId tmdbId)
            match result with
            | Ok details ->
                return ExactMatch {
                    TmdbId = tmdbId
                    MediaType = Movie
                    Title = details.Title
                    ReleaseDate = details.ReleaseDate
                    PosterPath = details.PosterPath
                    Overview = details.Overview
                    VoteAverage = details.VoteAverage
                }
            | Error _ -> return NoMatchFound
        | ImportSeries ->
            let! result = TmdbClient.getSeriesDetails (TmdbSeriesId tmdbId)
            match result with
            | Ok details ->
                return ExactMatch {
                    TmdbId = tmdbId
                    MediaType = Series
                    Title = details.Name
                    ReleaseDate = details.FirstAirDate
                    PosterPath = details.PosterPath
                    Overview = details.Overview
                    VoteAverage = details.VoteAverage
                }
            | Error _ -> return NoMatchFound
    | None ->
        // Priority 2: Try IMDB ID lookup
        match item.ImdbId with
        | Some imdbId ->
            let! imdbResult = TmdbClient.findByImdbId imdbId
            match imdbResult with
            | Some result ->
                // Verify media type matches
                let expectedMediaType = match item.MediaType with ImportMovie -> Movie | ImportSeries -> Series
                if result.MediaType = expectedMediaType then
                    return ExactMatch result
                else
                    // Media type mismatch, fall through to title search
                    return! matchByTitleSearch item
            | None ->
                // IMDB ID not found, fall through to title search
                return! matchByTitleSearch item
        | None ->
            // No IDs provided, search by title + year
            return! matchByTitleSearch item
}

// =====================================
// Friend Resolution
// =====================================

let private resolveFriends (friendNames: string list) : Async<GenericImportFriendResolution list> = async {
    let! allFriends = Persistence.getAllFriends()
    return friendNames
        |> List.map (fun name ->
            let existing =
                allFriends
                |> List.tryFind (fun f ->
                    f.Name.Equals(name, StringComparison.OrdinalIgnoreCase) ||
                    (f.Nickname |> Option.map (fun n -> n.Equals(name, StringComparison.OrdinalIgnoreCase)) |> Option.defaultValue false))
            match existing with
            | Some friend -> ExistingFriend friend.Id
            | None -> NewFriend name)
}

// =====================================
// Preview Generation
// =====================================

/// Generate a preview of what will be imported (with TMDB matching)
/// Resolve collection item references to matched items
let private resolveCollectionItems
    (items: GenericImportItem list)
    (itemsWithMatches: GenericImportItemWithMatch list)
    (collection: GenericImportCollection)
    : GenericImportCollectionSuggestion =

    let resolvedItems =
        collection.ItemRefs
        |> List.map (fun ref ->
            // Find the matching item in the items list
            let findResult =
                match ref with
                | ByCustomId customId ->
                    items
                    |> List.tryFindIndex (fun item -> item.Id = Some customId)
                    |> Option.map (fun idx -> idx, $"id: {customId}")
                | ByImdbId imdbId ->
                    items
                    |> List.tryFindIndex (fun item -> item.ImdbId = Some imdbId)
                    |> Option.map (fun idx -> idx, $"imdb: {imdbId}")
                | ByTmdbId (tmdbId, mediaType) ->
                    items
                    |> List.tryFindIndex (fun item ->
                        item.TmdbId = Some tmdbId && item.MediaType = mediaType)
                    |> Option.map (fun idx -> idx, $"tmdb: {tmdbId}")

            match findResult with
            | None ->
                let refStr =
                    match ref with
                    | ByCustomId id -> $"id '{id}'"
                    | ByImdbId id -> $"imdb_id '{id}'"
                    | ByTmdbId (id, _) -> $"tmdb_id '{id}'"
                Unresolved $"Item not found: {refStr}"
            | Some (idx, _) ->
                // Check if the item has a valid match
                let matchedItem = itemsWithMatches.[idx]
                match matchedItem.MatchStatus with
                | ExactMatch r | MatchConfirmed r ->
                    Resolved (idx, r.Title, r.PosterPath)
                | MultipleMatches _ ->
                    Unresolved $"'{matchedItem.ImportItem.Title}' has ambiguous match"
                | NoMatchFound | NotMatched ->
                    Unresolved $"'{matchedItem.ImportItem.Title}' has no TMDB match"
        )

    {
        Collection = collection
        ResolvedItems = resolvedItems
        Selected = false // User must explicitly select
    }

let generatePreview (parseResult: GenericImportParseResult) : Async<Result<GenericImportPreview, string>> = async {
    let items = parseResult.Items
    try
        let! itemsWithMatches =
            items
            |> List.mapi (fun idx item -> async {
                printfn "[GenericImport] Matching item %d/%d: %s" (idx + 1) items.Length item.Title
                let! matchStatus = matchWithTmdb item
                let! existsInLibrary =
                    match matchStatus with
                    | ExactMatch r | MatchConfirmed r ->
                        match item.MediaType with
                        | ImportMovie ->
                            async {
                                let! result = Persistence.isMovieInLibrary (TmdbMovieId r.TmdbId)
                                return result.IsSome
                            }
                        | ImportSeries ->
                            async {
                                let! result = Persistence.isSeriesInLibrary (TmdbSeriesId r.TmdbId)
                                return result.IsSome
                            }
                    | _ -> async { return false }
                let! resolvedFriends = resolveFriends item.FriendNames
                return {
                    ImportItem = item
                    MatchStatus = matchStatus
                    ExistsInLibrary = existsInLibrary
                    ResolvedFriends = resolvedFriends
                }
            })
            |> Async.Sequential

        let itemsList = itemsWithMatches |> Array.toList

        // Store in state for later confirmation
        importState := { !importState with ProcessingItems = itemsList }

        // Collect new friends to create
        let newFriendsToCreate =
            itemsList
            |> List.collect (fun i ->
                i.ResolvedFriends
                |> List.choose (fun r ->
                    match r with
                    | NewFriend name -> Some name
                    | _ -> None))
            |> List.distinct

        // Resolve collection suggestions
        let suggestedCollections =
            parseResult.Collections
            |> List.map (resolveCollectionItems items itemsList)

        return Ok {
            Items = itemsList
            TotalItems = itemsList.Length
            ExactMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with ExactMatch _ | MatchConfirmed _ -> true | _ -> false) |> List.length
            AmbiguousMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with MultipleMatches _ -> true | _ -> false) |> List.length
            NoMatches = itemsList |> List.filter (fun i -> match i.MatchStatus with NoMatchFound -> true | _ -> false) |> List.length
            AlreadyInLibrary = itemsList |> List.filter (fun i -> i.ExistsInLibrary) |> List.length
            NewFriendsToCreate = newFriendsToCreate
            SuggestedCollections = suggestedCollections
        }
    with ex ->
        return Error $"Failed to generate preview: {ex.Message}"
}

/// Confirm a TMDB match for an ambiguous item
let confirmMatch (index: int) (selectedMatch: TmdbSearchResult) : Async<Result<GenericImportItemWithMatch, string>> = async {
    let state = !importState
    if index < 0 || index >= state.ProcessingItems.Length then
        return Error $"Invalid item index: {index}"
    else
        let item = state.ProcessingItems.[index]
        let! existsInLibrary =
            match item.ImportItem.MediaType with
            | ImportMovie ->
                async {
                    let! result = Persistence.isMovieInLibrary (TmdbMovieId selectedMatch.TmdbId)
                    return result.IsSome
                }
            | ImportSeries ->
                async {
                    let! result = Persistence.isSeriesInLibrary (TmdbSeriesId selectedMatch.TmdbId)
                    return result.IsSome
                }

        let updatedItem = {
            item with
                MatchStatus = MatchConfirmed selectedMatch
                ExistsInLibrary = existsInLibrary
        }

        // Update the item in state
        let updatedItems =
            state.ProcessingItems
            |> List.mapi (fun i x -> if i = index then updatedItem else x)
        importState := { state with ProcessingItems = updatedItems }

        return Ok updatedItem
}

// =====================================
// Import Execution
// =====================================

/// Import a single movie
let private importMovie (item: GenericImportItemWithMatch) (tmdbResult: TmdbSearchResult) : Async<Result<unit, string>> = async {
    let tmdbId = TmdbMovieId tmdbResult.TmdbId

    // Check if already in library
    let! existing = Persistence.isMovieInLibrary tmdbId
    match existing with
    | Some entryId ->
        // Movie already exists - add watch sessions for new dates or update existing ones
        // Get resolved friend IDs (only existing friends, new ones will be created)
        let friendIds =
            item.ResolvedFriends
            |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

        for watchDate in item.ImportItem.WatchDates do
            let! existingSessionId = Persistence.getMovieWatchSessionIdForDate entryId watchDate
            match existingSessionId with
            | Some sessionId ->
                // Session exists for this date - add friends to it
                for friendId in friendIds do
                    do! Persistence.addFriendToMovieSession sessionId friendId
            | None ->
                // No session for this date - create a new one
                let request: CreateMovieWatchSessionRequest = {
                    EntryId = entryId
                    WatchedDate = watchDate
                    Friends = friendIds
                    Name = Some "Generic Import"
                }
                let! _ = Persistence.insertMovieWatchSession request
                do! Persistence.markMovieWatched entryId (Some watchDate)

        // Update rating if we have one and entry doesn't
        match item.ImportItem.Rating with
        | Some rating ->
            let! entry = Persistence.getLibraryEntryById entryId
            match entry with
            | Some e when e.PersonalRating.IsNone ->
                do! Persistence.updatePersonalRating entryId (Some rating)
            | _ -> ()
        | None -> ()

        // Update notes if we have some and entry doesn't
        match item.ImportItem.Notes with
        | Some notes ->
            let! entry = Persistence.getLibraryEntryById entryId
            match entry with
            | Some e when e.Notes.IsNone ->
                do! Persistence.updateNotes entryId (Some notes)
            | _ -> ()
        | None -> ()

        return Ok ()
    | None ->
        // New movie - add to library
        let! detailsResult = TmdbClient.getMovieDetails tmdbId
        match detailsResult with
        | Error err -> return Error $"Failed to fetch movie details for {item.ImportItem.Title}: {err}"
        | Ok details ->
            // Cache images
            do! ImageCache.downloadPoster details.PosterPath
            do! ImageCache.downloadBackdrop details.BackdropPath

            // Get resolved friend IDs
            let friendIds =
                item.ResolvedFriends
                |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

            let request: AddMovieRequest = {
                TmdbId = tmdbId
                WhyAdded = Some {
                    RecommendedBy = None
                    RecommendedByName = None
                    Source = item.ImportItem.Source |> Option.orElse (Some "Generic Import")
                    Context = None
                    DateRecommended = None
                }
                InitialFriends = friendIds
            }

            let! entryResult = Persistence.insertLibraryEntryForMovie details request
            match entryResult with
            | Error err -> return Error err
            | Ok entry ->
                // Create watch sessions
                for watchDate in item.ImportItem.WatchDates do
                    let sessionRequest: CreateMovieWatchSessionRequest = {
                        EntryId = entry.Id
                        WatchedDate = watchDate
                        Friends = friendIds
                        Name = Some "Generic Import"
                    }
                    let! _ = Persistence.insertMovieWatchSession sessionRequest
                    do! Persistence.markMovieWatched entry.Id (Some watchDate)

                // Set rating
                match item.ImportItem.Rating with
                | Some rating -> do! Persistence.updatePersonalRating entry.Id (Some rating)
                | None -> ()

                // Set notes
                match item.ImportItem.Notes with
                | Some notes -> do! Persistence.updateNotes entry.Id (Some notes)
                | None -> ()

                return Ok ()
}

/// Import a single series
let private importSeries (item: GenericImportItemWithMatch) (tmdbResult: TmdbSearchResult) : Async<Result<unit, string>> = async {
    let tmdbId = TmdbSeriesId tmdbResult.TmdbId

    // Check if already in library
    let! existing = Persistence.isSeriesInLibrary tmdbId
    match existing with
    | Some entryId ->
        // Series already exists - import episode/season data
        let! entry = Persistence.getLibraryEntryById entryId
        match entry with
        | None -> return Error "Entry not found after check"
        | Some e ->
            let seriesId =
                match e.Media with
                | LibrarySeries s -> s.Id
                | _ -> failwith "Expected series"

            // Add friends to the entry
            let friendIds =
                item.ResolvedFriends
                |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)
            for friendId in friendIds do
                do! Persistence.addFriendToEntry entryId friendId

            let! defaultSession = Persistence.getDefaultSession entryId
            match defaultSession with
            | None -> return Error "No default session found"
            | Some session ->
                // Import season-level data
                for season in item.ImportItem.Seasons do
                    // Fetch season details to get episode count
                    let! seasonDetails = TmdbClient.getSeasonDetails tmdbId season.SeasonNumber
                    match seasonDetails with
                    | Ok details ->
                        for ep in details.Episodes do
                            do! Persistence.insertEpisodeProgressWithDate
                                    session.Id
                                    entryId
                                    seriesId
                                    season.SeasonNumber
                                    ep.EpisodeNumber
                                    season.WatchedDate
                    | Error _ -> ()

                // Import episode-level data
                for ep in item.ImportItem.Episodes do
                    do! Persistence.insertEpisodeProgressWithDate
                            session.Id
                            entryId
                            seriesId
                            ep.SeasonNumber
                            ep.EpisodeNumber
                            ep.WatchedDate

                // Update watch status
                do! Persistence.updateSeriesWatchStatusFromProgress entryId

                // Update rating if we have one and entry doesn't
                match item.ImportItem.Rating with
                | Some rating ->
                    match e.PersonalRating with
                    | None -> do! Persistence.updatePersonalRating entryId (Some rating)
                    | _ -> ()
                | None -> ()

                return Ok ()
    | None ->
        // New series - add to library
        let! detailsResult = TmdbClient.getSeriesDetails tmdbId
        match detailsResult with
        | Error err -> return Error $"Failed to fetch series details for {item.ImportItem.Title}: {err}"
        | Ok details ->
            // Cache images
            do! ImageCache.downloadPoster details.PosterPath
            do! ImageCache.downloadBackdrop details.BackdropPath

            // Get resolved friend IDs
            let friendIds =
                item.ResolvedFriends
                |> List.choose (fun r -> match r with ExistingFriend id -> Some id | _ -> None)

            let request: AddSeriesRequest = {
                TmdbId = tmdbId
                WhyAdded = Some {
                    RecommendedBy = None
                    RecommendedByName = None
                    Source = item.ImportItem.Source |> Option.orElse (Some "Generic Import")
                    Context = None
                    DateRecommended = None
                }
                InitialFriends = friendIds
            }

            let! entryResult = Persistence.insertLibraryEntryForSeries details request
            match entryResult with
            | Error err -> return Error err
            | Ok entry ->
                let seriesId =
                    match entry.Media with
                    | LibrarySeries s -> s.Id
                    | _ -> failwith "Expected series"

                let! defaultSession = Persistence.getDefaultSession entry.Id
                match defaultSession with
                | None -> return Error "No default session created"
                | Some session ->
                    // Import season-level data
                    for season in item.ImportItem.Seasons do
                        let! seasonDetails = TmdbClient.getSeasonDetails tmdbId season.SeasonNumber
                        match seasonDetails with
                        | Ok seasonDetail ->
                            // Cache season poster
                            do! ImageCache.downloadSeasonPoster seasonDetail.PosterPath
                            for ep in seasonDetail.Episodes do
                                do! Persistence.insertEpisodeProgressWithDate
                                        session.Id
                                        entry.Id
                                        seriesId
                                        season.SeasonNumber
                                        ep.EpisodeNumber
                                        season.WatchedDate
                        | Error _ -> ()

                    // Import episode-level data
                    for ep in item.ImportItem.Episodes do
                        do! Persistence.insertEpisodeProgressWithDate
                                session.Id
                                entry.Id
                                seriesId
                                ep.SeasonNumber
                                ep.EpisodeNumber
                                ep.WatchedDate

                    // Update watch status
                    do! Persistence.updateSeriesWatchStatusFromProgress entry.Id

                    // Set rating
                    match item.ImportItem.Rating with
                    | Some rating -> do! Persistence.updatePersonalRating entry.Id (Some rating)
                    | None -> ()

                    // Set notes
                    match item.ImportItem.Notes with
                    | Some notes -> do! Persistence.updateNotes entry.Id (Some notes)
                    | None -> ()

                    return Ok ()
}

/// Create new friends that don't exist yet
let private createNewFriends (items: GenericImportItemWithMatch list) : Async<Map<string, FriendId>> = async {
    let newFriendNames =
        items
        |> List.collect (fun i ->
            i.ResolvedFriends
            |> List.choose (fun r ->
                match r with
                | NewFriend name -> Some name
                | _ -> None))
        |> List.distinct

    let! newFriends =
        newFriendNames
        |> List.map (fun name -> async {
            try
                let request: CreateFriendRequest = { Name = name; Nickname = None }
                let! friend = Persistence.insertFriend request
                return Some (name, friend.Id)
            with _ ->
                return None
        })
        |> Async.Sequential

    return
        newFriends
        |> Array.choose id
        |> Array.toList
        |> Map.ofList
}

/// Create selected collections after items are imported
let private createSelectedCollections
    (items: GenericImportItemWithMatch list)
    (collections: GenericImportCollectionSuggestion list)
    : Async<unit> = async {

    // Only process selected collections
    let selectedCollections = collections |> List.filter (fun c -> c.Selected)

    for suggestion in selectedCollections do
        try
            // Check if collection with same name already exists
            let! existingCollection = Persistence.getCollectionByName suggestion.Collection.Name
            let! collection =
                match existingCollection with
                | Some existing ->
                    printfn "[GenericImport] Found existing collection '%s', adding items to it" suggestion.Collection.Name
                    async { return existing }
                | None ->
                    // Create the collection
                    let request : CreateCollectionRequest = {
                        Name = suggestion.Collection.Name
                        Description = suggestion.Collection.Description
                        LogoBase64 = None
                    }
                    Persistence.insertCollection request

            // Collect resolved items with their sorting date
            let resolvedItemsWithDates =
                suggestion.ResolvedItems
                |> List.choose (fun resolution ->
                    match resolution with
                    | Resolved (itemIndex, _, _) when itemIndex >= 0 && itemIndex < items.Length ->
                        let item = items.[itemIndex]
                        let tmdbResult =
                            match item.MatchStatus with
                            | ExactMatch r | MatchConfirmed r -> Some r
                            | _ -> None
                        match tmdbResult with
                        | Some result ->
                            // Use watch date if available, otherwise use release date
                            let sortDate =
                                match item.ImportItem.WatchDates |> List.tryHead with
                                | Some watchDate -> Some watchDate
                                | None -> result.ReleaseDate
                            Some (result, sortDate)
                        | None -> None
                    | _ -> None)
                |> List.sortBy (fun (_, sortDate) ->
                    // Sort by date, items without dates go to the end
                    match sortDate with
                    | Some d -> d
                    | None -> DateTime.MaxValue)

            // Add items to collection in sorted order
            for (result, _) in resolvedItemsWithDates do
                // Look up the EntryId by TMDB ID
                let! entryIdOpt =
                    match result.MediaType with
                    | Movie -> Persistence.isMovieInLibrary (TmdbMovieId result.TmdbId)
                    | Series -> Persistence.isSeriesInLibrary (TmdbSeriesId result.TmdbId)

                match entryIdOpt with
                | Some entryId ->
                    do! Persistence.addItemToCollection collection.Id (LibraryEntryRef entryId) None
                | None ->
                    printfn "[GenericImport] Could not find entry for '%s' to add to collection" result.Title

            match existingCollection with
            | Some _ -> printfn "[GenericImport] Added items to existing collection '%s'" suggestion.Collection.Name
            | None -> printfn "[GenericImport] Created collection '%s' with items" suggestion.Collection.Name
        with ex ->
            printfn "[GenericImport] Failed to create/update collection '%s': %s" suggestion.Collection.Name ex.Message
}

/// Start the import process
let startImport (items: GenericImportItemWithMatch list) (collections: GenericImportCollectionSuggestion list) : Async<Result<unit, string>> = async {
    // Filter to only items with confirmed matches
    let importableItems =
        items
        |> List.filter (fun i ->
            match i.MatchStatus with
            | ExactMatch _ | MatchConfirmed _ -> true
            | _ -> false)

    if importableItems.IsEmpty then
        return Error "No items with valid TMDB matches to import"
    else
        // Reset and start
        resetState ()
        importState := {
            !importState with
                InProgress = true
                TotalItems = importableItems.Length
                ProcessingItems = importableItems
        }

        try
            // Create new friends first
            let! newFriendMap = createNewFriends importableItems

            // Update items with new friend IDs
            let itemsWithNewFriends =
                importableItems
                |> List.map (fun item ->
                    let updatedFriends =
                        item.ResolvedFriends
                        |> List.map (fun r ->
                            match r with
                            | NewFriend name ->
                                match Map.tryFind name newFriendMap with
                                | Some id -> ExistingFriend id
                                | None -> r  // Keep as NewFriend if creation failed
                            | existing -> existing)
                    { item with ResolvedFriends = updatedFriends })

            // Import each item
            for idx in 0 .. itemsWithNewFriends.Length - 1 do
                if isCancelled () then
                    addError "Import cancelled by user"
                else
                    let item = itemsWithNewFriends.[idx]
                    let title = item.ImportItem.Title
                    updateProgress title idx

                    let tmdbResult =
                        match item.MatchStatus with
                        | ExactMatch r | MatchConfirmed r -> Some r
                        | _ -> None

                    match tmdbResult with
                    | None ->
                        // Create item info for skipped (no match)
                        let skippedInfo = {
                            Title = item.ImportItem.Title
                            PosterPath = None
                            MediaType = match item.ImportItem.MediaType with ImportMovie -> Movie | ImportSeries -> Series
                            Year = item.ImportItem.Year
                            WatchDate = item.ImportItem.WatchDates |> List.tryHead
                            FriendNames = item.ImportItem.FriendNames
                            Rating = item.ImportItem.Rating
                        }
                        addSkippedItem skippedInfo
                        incrementSkipped ()
                    | Some result ->
                        let! importResult =
                            match item.ImportItem.MediaType with
                            | ImportMovie -> importMovie item result
                            | ImportSeries -> importSeries item result

                        let itemInfo = {
                            Title = result.Title
                            PosterPath = result.PosterPath
                            MediaType = result.MediaType
                            Year = result.ReleaseDate |> Option.map (fun d -> d.Year)
                            WatchDate = item.ImportItem.WatchDates |> List.tryHead
                            FriendNames = item.ImportItem.FriendNames
                            Rating = item.ImportItem.Rating
                        }

                        match importResult with
                        | Ok () ->
                            addImportedItem itemInfo
                            incrementCompleted ()
                        | Error err ->
                            addError $"{title}: {err}"
                            addSkippedItem itemInfo
                            incrementSkipped ()

            // Create selected collections after items are imported
            if not (isCancelled ()) then
                do! createSelectedCollections itemsWithNewFriends collections

            importState := { !importState with InProgress = false }
            return Ok ()
        with ex ->
            importState := { !importState with InProgress = false }
            return Error $"Import failed: {ex.Message}"
}

// =====================================
// Manual TMDB Search
// =====================================

/// Search TMDB for manual match resolution
let searchTmdb (query: string) (mediaType: GenericImportMediaType) : Async<TmdbSearchResult list> = async {
    if String.IsNullOrWhiteSpace(query) then
        return []
    else
        let! results = TmdbClient.searchAll query
        // Filter by media type
        return results
            |> List.filter (fun r ->
                match mediaType with
                | ImportMovie -> r.MediaType = Movie
                | ImportSeries -> r.MediaType = Series)
}
